<html>
    <style>
    .canvasContainer {
        overflow: hidden;
    }
    </style>
    <body>
        <canvas
            id="canvas"
            class="canvasContainer"
            width="550px"
            height="275px"></canvas>
        <br>
        <canvas
            id="canvas2"
            class="canvasContainer"
            width="550px"
            height="275px"></canvas>
        <script src="./src/zealous.js"></script>
        <script src="./src/bvh.js"></script>
        <script>
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

const SHAPES_TAG = 1;
const BVH_OUTLINE_TAG = 2;

const COLOUR_BOX_DEFAULT = "#ff0000";
const COLOUR_BOX_OVERLAP = "#ff00ff";

const COLOUR_BVH_DEFAULT = "#ffff00";
const COLOUR_BVH_OVERLAP = "#00ff00";

let cursorId = -1;

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
// Tree Traversal
////////////////////////////////////////////////////////////////////
function RecursivePointTest(x, y, node, callback) {
	if (!node.VsPoint(x, y)) { return; }
	if (!node.left || !node.right) { callback(node); return; }
	RecursivePointTest(x, y, node.left, callback);
	RecursivePointTest(x, y, node.right, callback);
}

function RecursiveWalk(node, callback) {
    callback(node);
    if (node.left) { RecursiveWalk(node.left, callback); }
    if (node.right) { RecursiveWalk(node.right, callback); }
}

function WorldTickCallback(gs, deltaTime) {
	gs.dirty = true;
	//console.log(`World tick`);
	let cursor = gs.FindEntById(cursorId);
	if (cursor) {
		cursor.pos.x = gs.cursorPos.x;
		cursor.pos.y = gs.cursorPos.y;
	}
	
	let shapesToClear = gs.FindAllByTag(SHAPES_TAG);
	for (let i = 0; i < shapesToClear.length; ++i) {
		shapesToClear[i].colour = COLOUR_BOX_DEFAULT;
	}
	
	let overlaps = [];
	RecursivePointTest(gs.cursorPos.x, gs.cursorPos.y, bvh.root, (node) => {
		//console.log(`Overlapping node: `, node);
		overlaps.push(node.userData);
	});
	let str = "Set ";
	for (let i = 0; i < overlaps.length; ++i) {
		str += `${overlaps[i]}, `;
		let id = overlaps[i];
		let shape = gs.FindEntById(id);
		if (shape === null) {
			console.log(`No shape ${id}!`);
			continue;
		}
		shape.colour = COLOUR_BOX_OVERLAP;
	}
	console.log(str);
	//console.log(`Over ${overlaps} shapes`);
}

function GraphTickCallback(gs, deltaTime) {
	gs.dirty = true;
}

function AddBvhOutline(gs, node) {
    let pad = gs.pix2metre / 2;

    gs.AddOutline(
			box.pos.x,
			box.pos.y,
			(box.halfWidth + outlinePad),
			(box.halfHeight + outlinePad),
			'#ffff00');
}

function Box2AABB(box) {
    return {
        minX: box.x - box.hw,
        minY: box.y - box.hh,
        maxX: box.x + box.hw,
        maxY: box.y + box.hh,
    };
}

function HandBuildBvh(gs) {
    //let boxes = gs.GetBoxList();
    //console.log(`Build BVH for ${boxes.length} AABBs`);
    let nodes = [];
    /*
                1
               / \
              /   \
             2     3
            /\     /\
           /  \   /  \
           4   5 6    7
    */
    
	let one = new BvhNode();
	let two = new BvhNode();
	let three = new BvhNode();
    let four = new BvhNode();
    let five = new BvhNode();
    let six = new BvhNode();
    let seven = new BvhNode();
	
	// Bottom
    four.aabb = Box2AABB({ x: 131.7, y: 167.1, hw: 23.0, hh: 22.0 });
    five.aabb = Box2AABB({ x: 180.4, y: 187.1, hw: 46.5, hh: 46.0 });
    six.aabb = Box2AABB({ x: 275.5, y: 148.4, hw: 39.7, hh: 43.3 });
    seven.aabb = Box2AABB({ x: 464.8, y: 100.4, hw: 17.7, hh: 46.0 });
	four.userData = 28;
	five.userData = 29;
	six.userData = 30;
	seven.userData = 31;
	//four.userData = { shapeId: 28, outlineId: };
	
	two.aabb = BvhCombineAABBs(four.aabb, five.aabb);
	three.aabb = BvhCombineAABBs(six.aabb, seven.aabb);
	one.aabb = BvhCombineAABBs(two.aabb, three.aabb);
	// Link
	two.left = four;
	two.right = five;
	three.left = six;
	three.right = seven;
	one.left = two;
	one.right = three;
	
    let bvh = new Bvh();
    bvh.root = one;
    bvh.nodes = nodes;
    console.log(`Hand built ${bvh.nodes.length} nodes`);
    return bvh;
}

////////////////////////////////////////////////////////////////////
// Setup
////////////////////////////////////////////////////////////////////
function TreeTest(gs) {
    gs.RemoveAllByTag(BVH_OUTLINE_TAG);
    // Generate Tree
    let bvh = HandBuildBvh(gs);
    let numNodes = 0;
    RecursiveWalk(bvh.root, (node) => {
        let hw = (node.aabb.maxX - node.aabb.minX) / 2;
        let hh = (node.aabb.maxY - node.aabb.minY) / 2;
        let outline = gs.AddOutline(node.aabb.minX + hw, node.aabb.minY + hh, hw, hh, '#ffff00');
		outline.tag = BVH_OUTLINE_TAG;
        // gs.AddCircle(node.aabb.minX + hw, node.aabb.minY + hh, hw, '#ffff00');
        numNodes++;
    });
    /*
    // Draw outlines over nodes.
    let numNodes = bvh.nodes.length;
    
    // Draw nodes
    for (let i = 0; i < numNodes; ++i) {
        let node = bvh.nodes[i];
        let hw = (node.aabb.maxX - node.aabb.minX) / 2;
        let hh = (node.aabb.maxY - node.aabb.minY) / 2;
        gs.AddOutline(node.aabb.minX + hw, node.aabb.minY + hh, hw, hh, '#ffff00');
        gs.AddCircle(node.aabb.minX + hw, node.aabb.minY + hh, hw, '#ffff00');
    }
    */
    console.log(`Show ${numNodes} tree nodes`);
	return bvh;
}

// Create a bunch of boxes around for which the BVH will be constructed
function BuildWorld(canvasElementId) {
	let gs = new CreateEngineInstance(canvasElementId, WorldTickCallback);
	gs.CreateGrid();
	gs.Start(20);

	let canvas = document.getElementById(canvasElementId);

    // Create Some boxes to build a tree around:
	let min = new V2(0, 0);
    let max = new V2(canvas.width, canvas.height);
    let shapes = [
        { x: 131.7, y: 167.1, hw: 23.0, hh: 22.0 },
        { x: 180.4, y: 187.1, hw: 46.5, hh: 46.0 },
        { x: 275.5, y: 148.4, hw: 39.7, hh: 43.3 },
        { x: 464.8, y: 100.4, hw: 17.7, hh: 46.0 },
    ];
	let numShapes = shapes.length;
	//let numShapes = 4;
    //let padding = gs.pix2metre;
    let colour = '#ff0000';
	for (let i = 0; i < numShapes; ++i) {
        let box = gs.AddBox(
            shapes[i].x,
            shapes[i].y,
            shapes[i].hw,
            shapes[i].hh,
            colour);
        box.tag = SHAPES_TAG;
		console.log(`Add shape ${box.id}`);
		/*let halfWidth = RandomRange(16, 48);
		let halfHeight = RandomRange(16, 48);
		let x = RandomRange(
			min.x + (halfWidth + padding),
			max.x - (halfWidth + padding));
		let y = RandomRange(
			min.y + (halfHeight + padding),
			max.y - (halfHeight + padding));
        gs.AddBox(x, y, halfWidth, halfHeight, '#ff0000');
        */
    }
	let cursor = gs.AddCircle(0, 0, 4, '#00ffff');
	cursorId = cursor.id;
    // init a player object for giggles
	//let plyr = gs.AddBox(
    //    canvas.width / 2, canvas.height / 2, 16, 16, '#00ff00');
	//gs.playerId = plyr.id;
	return gs;
}

// Create a canvas scene for displaying the BVH tree as a graph
function BuildGraph(canvasElementId) {
    let gs = new CreateEngineInstance(canvasElementId, GraphTickCallback);
    gs.AddBox(300, 200, 64, 32, '#ffffff');
    gs.Start(2);
    return gs;
}

let gs1 = BuildWorld("canvas");
let gs2 = BuildGraph("canvas2");

let bvh = TreeTest(gs1);

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
        </script>
    </body>
</html>