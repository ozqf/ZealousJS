<html>
    <style>
    .canvasContainer {
        overflow: hidden;
    }
    .row {
        display: flex;
        flex-direction: row;
        justify-content: flex-start;
    }
    .column {
        display: flex;
        flex-direction: column;
        justify-content:flex-start;
    }
    .world-canvas {
        max-width: 550px;
        max-height: 450px;
    }
    </style>
    <body>
        <div class="column">
            <div class="row">
                <button onclick="RebuildTree()">Rebuild</button>
                <button onclick="ClearScene()">Clear</button>
                <div id="debugText"></div>
            </div>
            <canvas
                id="canvas"
                class="world-canvas"
                width="550px"
                height="450px"></canvas>
            <br>
            <canvas
                id="canvas2"
                class="canvasContainer"
                width="550px"
                height="64px"></canvas>
        </div>
        
        
        
        <script src="./src/zealous.js"></script>
        <script src="./src/bvh.js"></script>
        <script>
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

const TAG_BOXES = 1;
const TAG_BVH_OUTLINE = 2;
const TAG_CURSOR_BOX = 3;

const COLOUR_BOX_DEFAULT = "#ff0000ff";
const COLOUR_BOX_OVERLAP = "#00ffffff";

const COLOUR_BVH_DEFAULT = "#999999ff";
const COLOUR_BVH_OVERLAP = "#ffff00ff";

let cursorId = -1;
let debugText = "";

////////////////////////////////////////////////////////////////////
// Utils
////////////////////////////////////////////////////////////////////
function SetDebugText(str) {
    debugText = str;
    let div = document.getElementById("debugText");
    div.innerHTML = debugText;
}

////////////////////////////////////////////////////////////////////
// Tree Traversal
////////////////////////////////////////////////////////////////////
function RecursivePointTest(x, y, node, callback) {
    //console.log(`Point test node ${node.id}`);
	if (!node.VsPoint(x, y)) { return; }
	if (!node.left || !node.right) { callback(node); return; }
	RecursivePointTest(x, y, node.left, callback);
	RecursivePointTest(x, y, node.right, callback);
}

function RecursiveWalk(node, callback) {
    callback(node);
    if (node.left) { RecursiveWalk(node.left, callback); }
    if (node.right) { RecursiveWalk(node.right, callback); }
}

function WorldTickCallback(gs, input, deltaTime) {
    let cursor = gs.FindEntById(cursorId);
	if (cursor) {
		cursor.pos.x = gs.cursorPos.x;
		cursor.pos.y = gs.cursorPos.y;
    }

    if (input.mouseOneClick) {
        // Add shape, rebuild tree
        let box = gs.AddBox(cursor.pos.x, cursor.pos.y, 16, 16, COLOUR_BOX_DEFAULT);
        box.tag = TAG_BOXES;
        CreateBvhForShapes(gs);
    }

    // Check raw AABB vs first shape
    /*
    let aabb = cursor.ToAABB();
    let shapes = gs.FindAllByTag(TAG_BOXES);
    let len = shapes.length;
    let box;
    if (len === 0) {
        box = gs.AddBox(128, 128, 32, 32, COLOUR_BOX_DEFAULT);
        box.tag = TAG_BOXES;
        len = 1;
    }
    else { box = shapes[0]; }
    let boxAABB = box.ToAABB();
    if (OverlapAABBs(aabb, boxAABB)) {
        console.log(`OVERLAP!`);
    }
    */
    // Analyse tree
    
	let boxes = gs.FindAllByTag(TAG_BOXES);
	for (let i = 0; i < boxes.length; ++i) {
        boxes[i].colour = COLOUR_BOX_DEFAULT;
        boxes[i].depth = 75;
    }
    let outlines = gs.FindAllByTag(TAG_BVH_OUTLINE);
    for (let i = 0; i < outlines.length; ++i) {
        outlines[i].colour = COLOUR_BVH_DEFAULT;
        outlines[i].depth = 50;
    }
    let overlaps = [];
    let visits = [];
    
    let PointTestVisit = (x, y, node, callback) => {
        visits.push(node.id);
        //if (!node.VsPoint(x, y)) { return false; }
        if (!node.left || !node.right) { callback(node); return true; }
        if (node.left.VsPoint(x, y)) {
            PointTestVisit(x, y, node.left, callback);
        }
        if (node.right.VsPoint(x, y)) {
            PointTestVisit(x, y, node.right, callback);
        }
        //PointTest(x, y, node.left, callback);
        //PointTest(x, y, node.right, callback);
        return true;
    };
    let x = gs.cursorPos.x, y = gs.cursorPos.y;
    if (gs.bvh.root !== null) {
        if (gs.bvh.root.VsPoint(x, y)) {
            PointTestVisit(x, y, gs.bvh.root, (node) => {
            overlaps.push(node.userData);
            });
        }
        //PointTest(gs.cursorPos.x, gs.cursorPos.y, gs.bvh.root, (node) => {
	    //	overlaps.push(node.userData);
        //});
    }
    else {
        console.log(`Tree has no root`);
    }
    let percentage = 0;
    if (gs.bvh.nextNodeId > 0) {
        percentage = Math.round(visits.length / (gs.bvh.nextNodeId) * 100);
    }
    let ratio = visits.length / boxes.length * 100;
    ratio = Math.round(ratio) / 100;
    let output = `Of ${boxes.length} shapes:`
    output += `Over ${overlaps.length}: `
    output += `visited ${visits.length} of ${gs.bvh.nextNodeId} nodes `
    output += `(${percentage}%) - ratio ${ratio}`;
    SetDebugText(output);
    //console.log(`Of ${boxes.length} shapes: Over ${overlaps.join(", ")} visited ${visits.length} (${percentage}%)`);
    //console.log(`nodes: ${visits.join(", ")}`);
	for (let i = 0; i < overlaps.length; ++i) {
		let id = overlaps[i];
		let shape = gs.FindEntById(id);
		if (shape === null) {
			console.log(`No shape ${id}!`);
			continue;
		}
		shape.colour = COLOUR_BOX_OVERLAP;
    }
    for (let i = 0; i < visits.length; ++i) {
        let outline = gs.FindEntByExternalId(visits[i]);
        if (outline === null) {
            console.log(`No Node ${visits[i]} found!`);
            continue;
        }
        outline.colour = COLOUR_BVH_OVERLAP;
        outlines[i].depth = 0;
    }
}

function GraphTickCallback(gs, input, deltaTime) {
}

function AddBvhOutline(gs, node) {
    let pad = gs.pix2metre / 2;

    gs.AddOutline(
		box.pos.x,
		box.pos.y,
		(box.halfWidth + outlinePad),
		(box.halfHeight + outlinePad),
		'#ffff00');
}

function Box2AABB(box) {
    return {
        minX: box.x - box.hw,
        minY: box.y - box.hh,
        maxX: box.x + box.hw,
        maxY: box.y + box.hh
    };
}

////////////////////////////////////////////////////////////////////
// Build Tree
////////////////////////////////////////////////////////////////////
function ClearScene() {
    world.RemoveAllByTag(TAG_BOXES);
    RebuildTree();
}

function RebuildTree() {
    CreateBvhForShapes(world);
    world.dirty = true;
}

function Foo(bvh, queryNode, newNode) {
    if (queryNode.IsLeaf()) {
        // split into branch and append leaves
        // queryNode becomes a branch
        // append copy of queryNode + new node as leaves
        let sibling = new BvhNode();
        sibling.id = bvh.nextNodeId++;
        sibling.userData = queryNode.userData;
        queryNode.userData = null;
        CopyAABB(queryNode.aabb, sibling.aabb);
        queryNode.aabb = BvhCombineAABBs(sibling.aabb, newNode.aabb);
        queryNode.left = sibling;
        queryNode.right = newNode;
    } else {
        // regardless of which child the shape is appended to we must
        // enlarge to include the new shape!
        queryNode.aabb = BvhCombineAABBs(queryNode.aabb, newNode.aabb);
        // test whether left or right would be better to continue down
        let scoreLeft = CompareAABBs(queryNode.left.aabb, newNode.aabb);
        let scoreRight = CompareAABBs(queryNode.right.aabb, newNode.aabb);
        if (scoreLeft < scoreRight) {
            Foo(bvh, queryNode.left, newNode);
        } else {
            Foo(bvh, queryNode.right, newNode);
        }
    }
}

function Shuffle(a) {
    let i, j, x;
    for (i = a.length - 1; i > 0; --i) {
        const j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
}

function AutoBuildBvh(gs) {
    let shapes = gs.FindAllByTag(TAG_BOXES);
    // Shuffle shapes to rearrange insertion order
    // (improves tree balance)
    Shuffle(shapes);
    let bvh = new Bvh();
    let numShapes = shapes.length;
    for (let i = 0; i < numShapes; ++i) {
        let shape = shapes[i];
        let node = new BvhNode();
        node.id = bvh.nextNodeId++;
        node.aabb = shape.ToAABB();
        node.userData = shape.id;
        if (bvh.root === null) {
            bvh.root = node;
            continue;
        }

        let queryNode = bvh.root;
        // Explore tree until a node to split is found
        Foo(bvh, queryNode, node);
    }
    return bvh;
}

function HandBuildBvh(gs) {
    //let boxes = gs.GetBoxList();
    //console.log(`Build BVH for ${boxes.length} AABBs`);
    let nodes = [];
    /*
                 1
               /   \
             /       \
            2         3
    */
    /*
                 1
               /   \
             /       \
            2         3
           / \
          /   \
         4     5
    */
    /*
                 1
               /   \
             /       \
            2         3
           / \       / \
          /   \     /   \
         4     5   6     7
    */
    
	let one = new BvhNode();
	let two = new BvhNode();
	let three = new BvhNode();
    let four = new BvhNode();
    let five = new BvhNode();
    let six = new BvhNode();
    let seven = new BvhNode();
	let eight = new BvhNode();
	let nine = new BvhNode();
	// Bottom
    four.aabb = Box2AABB({ x: 131.7, y: 167.1, hw: 23.0, hh: 22.0 });
    five.aabb = Box2AABB({ x: 180.4, y: 187.1, hw: 46.5, hh: 46.0 });
    six.aabb = Box2AABB({ x: 275.5, y: 148.4, hw: 39.7, hh: 43.3 });
    seven.aabb = Box2AABB({ x: 464.8, y: 100.4, hw: 17.7, hh: 46.0 });
	four.userData = 28;
	five.userData = 29;
	six.userData = 30;
	seven.userData = 31;
	//four.userData = { shapeId: 28, outlineId: };
	
	two.aabb = BvhCombineAABBs(four.aabb, five.aabb);
	three.aabb = BvhCombineAABBs(six.aabb, seven.aabb);
	one.aabb = BvhCombineAABBs(two.aabb, three.aabb);
	// Link
	two.left = four;
	two.right = five;
	three.left = six;
	three.right = seven;
	one.left = two;
	one.right = three;
	
    let bvh = new Bvh();
    bvh.root = one;
    bvh.nodes = nodes;
    console.log(`Hand built ${bvh.nodes.length} nodes`);
    return bvh;
}

////////////////////////////////////////////////////////////////////
// Setup
////////////////////////////////////////////////////////////////////
function CreateBvhForShapes(gs) {
    gs.RemoveAllByTag(TAG_BVH_OUTLINE);
    // Generate Tree
    //let bvh = HandBuildBvh(gs);2
    gs.bvh = AutoBuildBvh(gs);
    
    if (gs.bvh.root === null) {
        return gs.bvh;
    }

    let numNodes = 0;
    // Build display outlines
    RecursiveWalk(gs.bvh.root, (node) => {
        //let a = x.aabb;
        //console.log(`Draw node min ${a.minX}, ${a.minY} max ${a.maxX}, ${a.maxY}`);
        let hw = (node.aabb.maxX - node.aabb.minX) / 2;
        let hh = (node.aabb.maxY - node.aabb.minY) / 2;
        let outline = gs.AddOutline(node.aabb.minX + hw, node.aabb.minY + hh, hw, hh, '#ffff00');
        outline.externalId = node.id;
        outline.tag = TAG_BVH_OUTLINE;
        //console.log(`Outline for node ${node.id}`);
        // gs.AddCircle(node.aabb.minX + hw, node.aabb.minY + hh, hw, '#ffff00');
        numNodes++;
    });
    /*
    // Draw outlines over nodes.
    let numNodes = bvh.nodes.length;
    
    // Draw nodes
    for (let i = 0; i < numNodes; ++i) {
        let node = bvh.nodes[i];
        let hw = (node.aabb.maxX - node.aabb.minX) / 2;
        let hh = (node.aabb.maxY - node.aabb.minY) / 2;
        gs.AddOutline(node.aabb.minX + hw, node.aabb.minY + hh, hw, hh, '#ffff00');
        gs.AddCircle(node.aabb.minX + hw, node.aabb.minY + hh, hw, '#ffff00');
    }
    */
    console.log(`Show ${numNodes} tree nodes`);
}

// Create a bunch of boxes around for which the BVH will be constructed
function BuildWorld(canvasElementId) {
	let gs = new CreateEngineInstance(canvasElementId, WorldTickCallback);
	//gs.CreateGrid(100);
    gs.Start(20);
    gs.bvh = new Bvh();

    let canvas = document.getElementById(canvasElementId);
    // Create Some boxes to build a tree around:
    let colour = '#ff0000';
    const randomised = true;
    if (randomised)
    {
        let min = new V2(0, 0);
        let max = new V2(canvas.width, canvas.height);
        let numShapes = 0;
        let padding = gs.pix2metre;
	    for (let i = 0; i < numShapes; ++i) {
	    	let halfWidth = RandomRange(16, 48);
	    	let halfHeight = RandomRange(16, 48);
	    	let x = RandomRange(
	    		min.x + (halfWidth + padding),
	    		max.x - (halfWidth + padding));
	    	let y = RandomRange(
	    		min.y + (halfHeight + padding),
	    		max.y - (halfHeight + padding));
            let box = gs.AddBox(x, y, halfWidth, halfHeight, '#ff0000');
            box.tag = TAG_BOXES;
            console.log(`Add shape ${box.id}`);
        }   
    }
    else
    {
        let shapes = [
            { x: 131.7, y: 167.1, hw: 23.0, hh: 22.0 },
            { x: 180.4, y: 187.1, hw: 46.5, hh: 46.0 },
            { x: 275.5, y: 148.4, hw: 39.7, hh: 43.3 },
            //{ x: 464.8, y: 100.4, hw: 17.7, hh: 46.0 },
        ];
        let numShapes = shapes.length;
	    for (let i = 0; i < numShapes; ++i) {
            let box = gs.AddBox(
                shapes[i].x,
                shapes[i].y,
                shapes[i].hw,
                shapes[i].hh,
                colour);
            box.tag = TAG_BOXES;
	    	console.log(`Add shape ${box.id}`);
        }
    }
    
	let cursor = gs.AddCircle(0, 0, 32, '#00ffff');
	cursorId = cursor.id;
    // init a player object for giggles
	//let plyr = gs.AddBox(
    //    canvas.width / 2, canvas.height / 2, 16, 16, '#00ff00');
	//gs.playerId = plyr.id;
	return gs;
}

// Create a canvas scene for displaying the BVH tree as a graph
function BuildGraph(canvasElementId) {
    let gs = new CreateEngineInstance(canvasElementId, GraphTickCallback);
    gs.AddBox(300, 200, 64, 32, '#ffffff');
    gs.Start(2);
    return gs;
}

let world = BuildWorld("canvas");
let graph = BuildGraph("canvas2");

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
        </script>
    </body>
</html>