<html>
    <style>
    .canvasContainer {
        overflow: hidden;
    }
    </style>
    <body>
        <canvas
            id="canvas"
            class="canvasContainer"
            width="640px"
            height="400px"></canvas>
        <br>
        <canvas
            id="canvas2"
            class="canvasContainer"
            width="640px"
            height="400px"></canvas>
        <script src="./src/zealous.js"></script>
        <script src="./src/bvh.js"></script>
        <script>
//


function AddBvhOutline(gs, node) {
    let pad = gs.pix2metre / 2;

    gs.AddOutline(
			box.pos.x,
			box.pos.y,
			(box.halfWidth + outlinePad),
			(box.halfHeight + outlinePad),
			'#ffff00');
}

function HandBuildBvh() {
	
}

function BuildBvh(gs) {
    let boxes = gs.GetBoxList();
    console.log(`Build BVH for ${boxes.length} AABBs`);
    gs.ClearOutlines();

    let bvh = new Bvh();

    // Create Tree
	let outlinePad = gs.pix2metre / 2;
	for (let i = 0; i < boxes.length; ++i) {
        let box = boxes[i];
        bvh.Insert(box);
        /*
		gs.AddOutline(
			box.pos.x,
			box.pos.y,
			(box.halfWidth + outlinePad),
			(box.halfHeight + outlinePad),
            '#ffff00');
        */
    }
    return bvh;
}

function BuildWorld(canvasElementId) {
	let gs = new CreateEngineInstance(canvasElementId);
	gs.CreateGrid();
	gs.Start(2);

	let canvas = document.getElementById(canvasElementId);

    // Create Some boxes to build a tree around:
	let min = new V2(0, 0);
	let max = new V2(canvas.width, canvas.height);
	let numShapes = 4;
	let padding = gs.pix2metre;
	for (let i = 0; i < numShapes; ++i) {
		let halfWidth = RandomRange(32, 64);
		let halfHeight = RandomRange(32, 64);
		let x = RandomRange(
			min.x + (halfWidth + padding),
			max.x - (halfWidth + padding));
		let y = RandomRange(
			min.y + (halfHeight + padding),
			max.y - (halfHeight + padding));
		gs.AddBox(x, y, halfWidth, halfHeight, '#ff0000');
    }
    // init a player object for giggles
	//let plyr = gs.AddBox(
    //    canvas.width / 2, canvas.height / 2, 16, 16, '#00ff00');
	//gs.playerId = plyr.id;
	return gs;
}

function DrawBvhVolumes(gs) {
	let bvh = BuildBvh(gs);
    let numNodes = bvh.nodes.length;
    console.log(`Show ${numNodes} tree nodes`);
    // Draw nodes
    for (let i = 0; i < numNodes; ++i) {
        let node = bvh.nodes[i];
        let hw = (node.aabb.maxX - node.aabb.minX) / 2;
        let hh = (node.aabb.maxY - node.aabb.minY) / 2;
        gs.AddOutline(node.aabb.minX + hw, node.aabb.minY + hh, hw, hh, '#ffff00');
    }
	return bvh;
}

function BuildGraph(canvasElementId) {
    let gs = new CreateEngineInstance(canvasElementId);
    gs.AddBox(300, 200, 64, 32, '#ffffff');
    gs.Start(2);
    return gs;
}

let gs1 = BuildWorld("canvas");
let gs2 = BuildGraph("canvas2");


let bvh = DrawBvhVolumes(gs1);

//
        </script>
    </body>
</html>